# Документация по тестам и анализу уязвимостей

Документ описывает проведённый анализ кода с точки зрения тестировщика и специалиста по информационной безопасности, внесённые исправления и полный перечень тестов.

---

## 1. Выявленные слабые места (до исправлений)

### 1.1 Критические (безопасность)

| Уязвимость | Где | Описание |
|------------|-----|----------|
| **Path Traversal** | `server/config/localStorage.js`, маршруты с `:key` | Ключ из URL подставлялся в `path.join(FILES_DIR, key)` без проверки. Запрос к `/files/../../../etc/passwd` или `/download/..%2F..%2Fsecret` позволял читать/удалять файлы вне директории хранилища. |
| **Небезопасное имя при загрузке** | `server/routes/localStorage.js` (multer filename) | `file.originalname` мог содержать `..` или слеши — в хранилище попадал ключ вида `123-../../evil.txt`, что создавало риск обхода ограничений. |

### 1.2 Высокий приоритет

| Слабость | Где | Описание |
|----------|-----|----------|
| **Отсутствие аутентификации** | Все эндпоинты | API полностью публичное. Любой может загружать, скачивать и удалять файлы. Для продакшена нужна хотя бы простая аутентификация (API key, JWT, сессии). |
| **Нет валидации типа файла** | Multer `fileFilter` | Принимаются любые файлы (в т.ч. исполняемые, скрипты). Риск загрузки вредоносного контента и XSS при превью. Рекомендуется whitelist MIME/расширений и проверка содержимого. |
| **Header Injection в Content-Disposition** | `server/routes/localStorage.js` (download) | `filename="${fileInfo.metadata?.originalName}"` — если в имени есть кавычки или CRLF, возможна подмена заголовков ответа. Нужно экранировать или использовать только ASCII. |
| **Нет лимита на количество ключей при массовом удалении** | `DELETE /files` | В body можно передать массив `keys` произвольного размера — риск DoS и перегрузки. Рекомендуется ограничение (например, не более 100 ключей). |

### 1.3 Средний приоритет

| Слабость | Описание |
|----------|----------|
| **Нет rate limiting** | Возможен DoS массовыми загрузками/скачиваниями/удалениями. |
| **CORS** | Зависит от `CLIENT_URL`; при неверной настройке возможен доступ с произвольных доменов. |
| **Утечка стека в ошибках** | В `NODE_ENV=development` в ответ уходит `stack` — не показывать в продакшене (уже учтено в коде). |
| **Размер файла 100 MB** | Лимит есть, но для публичного API может быть избыточным без аутентификации. |

### 1.4 Низкий приоритет / качество кода

| Слабость | Описание |
|----------|----------|
| **Ошибки при удалении несуществующего файла** | DELETE по несуществующему ключу может возвращать 200 или 500 в зависимости от реализации — лучше явно 404. |
| **Пустой ключ** | GET `/files/` (пустой key) в зависимости от порядка маршрутов может обрабатываться как список файлов — желательно явно возвращать 400. |

---

## 2. Внесённые исправления

1. **Path Traversal (локальное хранилище)**  
   - В `server/config/localStorage.js`: добавлена проверка ключа `isKeySafe(key)` — запрещены `..`, абсолютные пути, пустая строка и не-строка.  
   - `getFilePath(key)` и `getMetadataPath(key)` выбрасывают `Error('Invalid key')` при небезопасном ключе.  
   - Во всех маршрутах localStorage при поимке `Invalid key` возвращается **400** с телом `{ "error": "Invalid key" }`.

2. **Санитизация имени при загрузке**  
   - В `server/routes/localStorage.js` (multer): из `file.originalname` удаляются `..` и слеши (`/`, `\`), чтобы ключ не содержал path traversal.

3. **Тестовая изоляция**  
   - В `server/config/localStorage.js` добавлена поддержка `process.env.STORAGE_DIR` для тестов; в тестах используется временная директория в `os.tmpdir()`.

---

## 3. Структура тестов

- **Среда:** Node.js, Jest, supertest.  
- **Запуск:** `npm test`.  
- **Файлы:**  
  - `server/__tests__/setup.js` — установка env для тестов (не содержит тестов).  
  - `server/__tests__/api.test.js` — контракт API и сценарии использования.  
  - `server/__tests__/security.test.js` — проверки безопасности (path traversal, невалидные ключи).  
  - `server/__tests__/localStorage.config.test.js` — юнит-тесты конфигурации хранилища (безопасность ключа).

---

## 4. Описание тестов (что делают и зачем)

### 4.1 Health check

| Тест | Что делает | Зачем |
|------|------------|--------|
| `GET /api/health returns 200 and status ok` | Вызывает `GET /api/health`, проверяет статус 200 и наличие поля `status: 'ok'`. | Убедиться, что API поднят и отвечает по контракту; используется мониторингом и оркестрацией. |

### 4.2 POST /upload

| Тест | Что делает | Зачем |
|------|------------|--------|
| `returns 400 when no file is sent` | Отправляет POST без поля `file`. | Проверка валидации: отсутствие файла должно давать 400, а не 500. |
| `returns 200 and file info when a file is uploaded` | Загружает один файл, проверяет 200, наличие `success`, `file.key`, `bucket`, `originalName`, `size`, `contentType`, `uploadedAt`, `location`. После теста файл удаляется. | Проверка контракта IDF: успешная загрузка и корректная структура ответа. |

### 4.3 POST /upload-multiple

| Тест | Что делает | Зачем |
|------|------------|--------|
| `returns 400 when no files are sent` | POST без поля `files`. | Валидация: пустая множественная загрузка — 400. |
| `returns 200 and files array when multiple files are uploaded` | Загружает два файла, проверяет массив `files`, наличие `key` и `originalName`. Удаляет загруженные файлы. | Контракт: множественная загрузка возвращает массив файлов с ожидаемой структурой. |

### 4.4 GET /files

| Тест | Что делает | Зачем |
|------|------------|--------|
| `returns 200 with success, count and files array` | Вызывает список файлов, проверяет 200, `success`, `count`, тип `files` (массив). | Контракт списка файлов по IDF. |

### 4.5 GET /files/:key

| Тест | Что делает | Зачем |
|------|------------|--------|
| `returns 404 for non-existent key` | Запрос по ключу, которого нет в хранилище. | Корректная обработка «файл не найден» — 404, а не 500. |
| `returns 200 and file info for existing file` | Загружает файл, запрашивает его по key, проверяет 200 и поля `file.key`, `size`, `contentType`, `metadata`. Удаляет файл. | Контракт получения метаданных файла. |

### 4.6 GET /download/:key

| Тест | Что делает | Зачем |
|------|------------|--------|
| `returns 404 for non-existent key` | Скачивание по несуществующему ключу. | 404 при отсутствии файла. |
| `returns 200 with file body and Content-Disposition for existing file` | Загружает файл с содержимым `download-me`, скачивает его, проверяет 200, заголовок `Content-Disposition` (attachment), точное совпадение тела ответа с `download-me`. Удаляет файл. | Проверка, что скачивание возвращает бинарное тело и корректные заголовки (IDF). |

### 4.7 GET /preview/:key

| Тест | Что делает | Зачем |
|------|------------|--------|
| `returns 404 for non-existent key` | Превью по несуществующему ключу. | 404 при отсутствии файла. |
| `returns 200 with url and expiresIn for existing file` | Загружает файл, запрашивает preview, проверяет наличие `url` и `expiresIn`, что `url` содержит `/view`. Удаляет файл. | Контракт: превью возвращает URL и срок действия. |

### 4.8 GET /files/:key/view

| Тест | Что делает | Зачем |
|------|------------|--------|
| `returns 404 for non-existent key` | Просмотр по несуществующему ключу. | 404 при отсутствии файла. |
| `returns 200 with file content for existing file` | Загружает файл с содержимым `view-me`, запрашивает `/files/:key/view`, проверяет 200 и точное содержимое тела. Удаляет файл. | Inline-просмотр возвращает тело файла без скачивания (IDF). |

### 4.9 DELETE /files/:key

| Тест | Что делает | Зачем |
|------|------------|--------|
| `returns 200 and success for existing file` | Загружает файл, удаляет по key, проверяет 200 и `success: true`, затем проверяет, что GET по этому key возвращает 404. | Успешное удаление и консистентность состояния. |
| `returns 404 or 500 for non-existent key` | Удаление по несуществующему ключу. Допускаются 404 или 500 в зависимости от реализации. | Избежать падения сервера при удалении несуществующего файла. |

### 4.10 DELETE /files (массовое удаление)

| Тест | Что делает | Зачем |
|------|------------|--------|
| `returns 400 when keys are missing` | DELETE с телом `{}` (без `keys`). | Валидация: отсутствие `keys` — 400. |
| `returns 400 when keys is not an array` | Body: `{ keys: 'not-array' }`. | Защита от неверного типа. |
| `returns 400 when keys is empty array` | Body: `{ keys: [] }`. | Пустой массив ключей — 400. |
| `returns 200 and deleted array when keys are provided` | Загружает файл, удаляет через bulk DELETE с массивом из одного key, проверяет 200 и наличие `deleted`. | Контракт массового удаления по IDF. |

---

### 4.11 Security: path traversal и невалидные ключи

| Тест | Что делает | Зачем |
|------|------------|--------|
| `rejects key containing .. (path traversal)` | GET `/files/../../../etc/passwd` (URL-encoded). | Убедиться, что path traversal по ключу отклоняется (400 Invalid key). |
| `rejects key with encoded ..` | GET с ключом `..%2F..%2Fetc%2Fpasswd`. | Двойная проверка: обход через кодирование тоже блокируется. |
| `rejects key that is absolute path` | GET с ключом `/etc/passwd`. | Абсолютные пути в ключе запрещены. |
| `rejects empty key or returns 404` | GET `/files/` (пустой key). | Либо 400, либо 404; при 200 проверяется, что это ответ «списка» (есть `files`). |
| Аналогичные проверки для **GET /download/:key**, **GET /preview/:key**, **GET /files/:key/view**, **DELETE /files/:key** | Те же типы атак (path traversal, закодированный `..`, абсолютный путь) для каждого эндпоинта с `:key`. | Одинаковая политика безопасности для всех операций с ключом. |
| `reports invalid key in errors when one key is path traversal` | Bulk DELETE с массивом `['valid-key', '../../../etc/passwd']`. Проверяется 200 и наличие в `errors` записи с `error: 'Invalid key'`. | Частичный успех: валидные ключи обрабатываются, невалидные возвращаются в `errors`, без path traversal. |
| `strips path traversal from original filename` | Загрузка файла с именем `../../evil.txt`. Проверяется, что в ответе `file.key` не содержит `..` и имеет вид `\d+-evil.txt`. Удаление созданного файла. | Санитизация имени при загрузке: в хранилище не попадают ключи с `..`. |
| `replaces path separators in filename` | Загрузка с именем `folder/sub/file.txt`. Проверяется, что в key нет `/` и `\`. Удаление файла. | Имена с путями не создают поддиректории и не содержат слешей в ключе. |

---

### 4.12 Unit: localStorage config

| Тест | Что делает | Зачем |
|------|------------|--------|
| `accepts normal filename` | Вызов `getFilePath('123-doc.pdf')` не бросает, результат — путь внутри `FILES_DIR`. | Нормальные ключи принимаются. |
| `rejects key with ..` | `getFilePath('../../etc/passwd')` и `getMetadataPath('a/../b')` выбрасывают `Invalid key`. | Path traversal на уровне конфига. |
| `rejects absolute path` | `getFilePath('/etc/passwd')` выбрасывает. | Абсолютные пути запрещены. |
| `rejects empty key` | `getFilePath('')` выбрасывает. | Пустой ключ не допускается. |
| `rejects null/undefined` | `getFilePath(null)`, `getFilePath(undefined)` выбрасывают. | Защита от неверного типа. |
| `rejects non-string` | `getFilePath(123)` выбрасывает. | Тип ключа — строка. |
| `resolved file path stays inside FILES_DIR` | Для ключа `normal-file.txt` проверяется, что `path.resolve(getFilePath(...))` начинается с `path.resolve(FILES_DIR)`. | Гарантия, что результирующий путь не выходит за пределы хранилища. |

---

## 5. Как запускать тесты

```bash
npm test
```

Тесты используют отдельную временную директорию (`STORAGE_DIR` в `os.tmpdir()`), реальное хранилище `storage/` не затрагивается.

---

## 6. Рекомендации на будущее

1. Добавить аутентификацию/авторизацию для продакшена.  
2. Ввести whitelist типов файлов и, при необходимости, проверку содержимого.  
3. Экранировать или нормализовать `originalName` в `Content-Disposition`.  
4. Ограничить размер массива `keys` в `DELETE /files` (например, не более 100).  
5. Добавить rate limiting (по IP или по пользователю).  
6. Покрыть тестами маршруты S3 (с моками AWS SDK) при использовании облачного режима.
